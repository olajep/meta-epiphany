From bedc63e62c93111ca8f2ff95d4144f3f49a021fe Mon Sep 17 00:00:00 2001
From: Joern Rennecke <joern.rennecke@embecosm.com>
Date: Tue, 13 Aug 2013 12:36:57 +0100
Subject: [PATCH 10/33] * config/epiphany/predicates.md (pcrel_operand): New
 predicate. (move_src_operand): Exclude pcrel_operand for flag_pic.
 (nonsymbolic_immediate_operand): Rename to .. (nonpcrel_immediate_operand) ..
 this. Changed all users. Exclude pcrel_operand. *
 config/epiphany/constraints.md (Clb): New constraint. *
 config/epiphany/epiphany.h (ASM_OUTPUT_ADDR_DIFF_ELT): Use mode of BODY.
 (CASE_VECTOR_SHORTEN_MODE): Define. * config/epiphany/epiphany.md
 (UNSPEC_CASESI): New constant. (mov<mode>) <SImode>: Use gen_movsi_pcrel.
 (movsi_pcrel, movsi_pcrel_r, movsi_pcrel_r+[12]): New patterns.
 (tablejump_internal): Emit expander. (casesi, casesi_load): New patterns. *
 config/epiphany/epiphany.c (epiphany_secondary_reload): For flag_pic, handle
 pcrel_operand.

---
 gcc/ChangeLog.epiphany             |  19 ++++
 gcc/config/epiphany/constraints.md |   6 +-
 gcc/config/epiphany/epiphany.c     |   9 +-
 gcc/config/epiphany/epiphany.h     |  12 ++-
 gcc/config/epiphany/epiphany.md    | 139 ++++++++++++++++++++++++++++-
 gcc/config/epiphany/predicates.md  |  12 ++-
 6 files changed, 190 insertions(+), 7 deletions(-)

diff --git a/gcc/ChangeLog.epiphany b/gcc/ChangeLog.epiphany
index c21364e97c0..a708981a6cb 100644
--- a/gcc/ChangeLog.epiphany
+++ b/gcc/ChangeLog.epiphany
@@ -1,3 +1,22 @@
+2013-08-13  Joern Rennecke <joern.rennecke@embecosm.com>
+
+	* config/epiphany/predicates.md (pcrel_operand): New predicate.
+	(move_src_operand): Exclude pcrel_operand for flag_pic.
+	(nonsymbolic_immediate_operand): Rename to ..
+	(nonpcrel_immediate_operand) .. this.  Changed all users.
+	Exclude pcrel_operand.
+	* config/epiphany/constraints.md (Clb): New constraint.
+	* config/epiphany/epiphany.h (ASM_OUTPUT_ADDR_DIFF_ELT):
+	Use mode of BODY.
+	(CASE_VECTOR_SHORTEN_MODE): Define.
+	* config/epiphany/epiphany.md (UNSPEC_CASESI): New constant.
+	(mov<mode>) <SImode>: Use gen_movsi_pcrel.
+	(movsi_pcrel, movsi_pcrel_r, movsi_pcrel_r+[12]): New patterns.
+	(tablejump_internal): Emit expander.
+	(casesi, casesi_load): New patterns.
+	* config/epiphany/epiphany.c (epiphany_secondary_reload):
+	For flag_pic, handle pcrel_operand.
+
 2013-08-02  Joern Rennecke <joern.rennecke@embecosm.com>
 
 	* config/epiphany/epiphany.c (epiphany_compute_frame_size):
diff --git a/gcc/config/epiphany/constraints.md b/gcc/config/epiphany/constraints.md
index bb0317c7cea..9178b08da72 100644
--- a/gcc/config/epiphany/constraints.md
+++ b/gcc/config/epiphany/constraints.md
@@ -65,9 +65,13 @@
 (define_constraint "Cal"
   "Constant for arithmetic/logical operations"
   (match_test "(flag_pic
-		? nonsymbolic_immediate_operand (op, VOIDmode)
+		? nonpcrel_immediate_operand (op, VOIDmode)
 		: immediate_operand (op, VOIDmode))"))
 
+(define_constraint "Clb"
+  "Constant involving a label or overlay-local symbol"
+  (match_operand 0 "pcrel_operand"))
+
 (define_constraint "Csy"
   "Symbolic constant for call/jump instruction"
   (match_test "symbolic_operand (op, VOIDmode)"))
diff --git a/gcc/config/epiphany/epiphany.c b/gcc/config/epiphany/epiphany.c
index 18fecaf8fb6..590e1e6e416 100644
--- a/gcc/config/epiphany/epiphany.c
+++ b/gcc/config/epiphany/epiphany.c
@@ -2220,9 +2220,14 @@ epiphany_legitimate_address_p (machine_mode mode, rtx x, bool strict)
 
 static reg_class_t
 epiphany_secondary_reload (bool in_p, rtx x, reg_class_t rclass,
-			machine_mode mode ATTRIBUTE_UNUSED,
-			secondary_reload_info *sri)
+			machine_mode mode, secondary_reload_info *sri)
 {
+  if (in_p && flag_pic && pcrel_operand (x, mode))
+    {
+      gcc_assert (rclass == GENERAL_REGS);
+      sri->icode = CODE_FOR_movsi_pcrel_r;
+      return NO_REGS;
+    }
   /* This could give more reload inheritance, but we are missing some
      reload infrastructure.  */
  if (0)
diff --git a/gcc/config/epiphany/epiphany.h b/gcc/config/epiphany/epiphany.h
index b3b8e6d327a..42c3314f0d0 100644
--- a/gcc/config/epiphany/epiphany.h
+++ b/gcc/config/epiphany/epiphany.h
@@ -761,7 +761,7 @@ do { \
 /* This is how to output an element of a case-vector that is relative.  */
 #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \
 do {							\
-  if (CASE_VECTOR_MODE == Pmode) \
+  if (GET_MODE (BODY) == Pmode) \
     asm_fprintf ((FILE), "\t.word"); \
   else \
     asm_fprintf ((FILE), "\t.short"); \
@@ -823,6 +823,16 @@ do \
    for the index in the tablejump instruction.  */
 #define CASE_VECTOR_MODE (TARGET_SMALL16 && optimize_size ? HImode : Pmode)
 
+/* When generating PIC code, we are already need pc-relative switch tables;
+   the cost of a zero-extending load is relatively low compared to the
+   saving in code size (which is at a premium for overlays), so try to
+   use shorter tables unless optimize >= 3 (considering that -O3 is for
+   aggressive size increasing optimizations).  */
+#define CASE_VECTOR_SHORTEN_MODE(MIN, MAX, BODY) \
+  (TARGET_SMALL16 && optimize_size ? HImode \
+   : flag_pic && optimize < 3 && ((MIN) >= 0 && (MAX) < 65535) ? HImode \
+   : Pmode)
+
 /* Define if operations between registers always perform the operation
    on the full register even if a narrower mode is specified.  */
 #define WORD_REGISTER_OPERATIONS 1
diff --git a/gcc/config/epiphany/epiphany.md b/gcc/config/epiphany/epiphany.md
index 6f7e8614918..1b7fe5b43ab 100644
--- a/gcc/config/epiphany/epiphany.md
+++ b/gcc/config/epiphany/epiphany.md
@@ -50,6 +50,7 @@
    ; harder to determine when it must be saved.
    (UNSPEC_RETURN_ADDR		 0)
    (UNSPEC_FP_MODE		 1)
+   (UNSPEC_CASESI		 2)
 
    (UNSPECV_GID			 0)
    (UNSPECV_GIE			 1)])
@@ -135,6 +136,15 @@
       if (operands[0] == reg)
 	DONE;
     }
+  if (<MODE>mode == SImode && flag_pic && pcrel_operand (operands[1], Pmode))
+    {
+      if (reload_in_progress || reload_completed)
+	/* epiphany_secondary_reload should already have taken care of this.  */
+	gcc_unreachable ();
+      else
+	emit_insn (gen_movsi_pcrel (operands[0], operands[1]));
+      DONE;
+    }
 })
 
 (define_insn "*movqi_insn"
@@ -297,6 +307,77 @@
   "reload_in_progress || reload_completed"
   [(set (match_dup 0) (match_dup 1))])
 
+(define_insn "movsi_pcrel"
+  [(set (match_operand:SI 0 "gpr_operand" "=r")
+	(match_operand:SI 1 "pcrel_operand" "Clb"))
+   (clobber (match_scratch:SI 2 "=r"))
+   (clobber (reg:CC CC_REGNUM))]
+  "flag_pic"
+{
+  asm_fprintf (asm_out_file, "0:");
+  return (get_attr_length (insn) > 8
+	  ? "movfs %2,pc\;mov %0,%%low((%1)-0b)\;movt %0,%%high((%1)-0b)\;add %0,%0,%2 ; %1"
+	  : "movfs %0,pc\;add %0,%0,(%1)-0b");
+}
+  [(set_attr "type" "move")
+   (set (attr "length")
+	(if_then_else
+	  (leu (plus (minus (match_dup 0) (pc)) (const_int 1024))
+	       (const_int 2047))
+	  (const_int 8) (const_int 16)))])
+
+(define_insn "movsi_pcrel_r"
+  [(set (match_operand:SI 0 "gpr_operand" "=r")
+	(match_operand:SI 1 "pcrel_operand" "Clb"))
+   (clobber (match_operand:SI 2 "gpr_operand" "=r"))
+   (clobber (reg:CC UNKNOWN_REGNUM))]
+  "flag_pic && (reload_in_progress || reload_completed)"
+{
+  int scratch = (0x17
+		 ^ (true_regnum (operands[0]) & 1)
+		 ^ (true_regnum (operands[1]) & 2)
+		 ^ (true_regnum (operands[2]) & 4));
+  asm_fprintf (asm_out_file, "\tstr r%d,[sp,#0]\n", scratch);
+  asm_fprintf (asm_out_file, "\tmovfs r%d,status\n", scratch);
+  asm_fprintf (asm_out_file, "0:");
+  output_asm_insn ("movfs %2,pc", operands);
+  output_asm_insn ("mov %0,%%low((%1)-0b)\;movt %0,%%high((%1)-0b)", operands);
+  output_asm_insn ("add %0,%0,%2 ; %1", operands);
+  asm_fprintf (asm_out_file, "\tmovts status,r%d\n", scratch);
+  asm_fprintf (asm_out_file, "\tldr r%d,[sp,#0]\n", scratch);
+  return "";
+}
+  [(set_attr "type" "move")
+   (set_attr "length" "32")])
+
+(define_peephole2
+  [(match_parallel 5 ""
+     [(set (match_operand 3 "cc_operand" "") (match_operand 4 "" ""))])
+   (parallel [(set (match_operand:SI 0 "gpr_operand" "")
+		   (match_operand:SI 1 "pcrel_operand" ""))
+	      (clobber (match_operand:SI 2 "gpr_operand" ""))
+	      (clobber (reg:CC UNKNOWN_REGNUM))])]
+  "REGNO (operands[3]) == CC_REGNUM
+   && !reg_overlap_mentioned_p (operands[0], operands[5])
+   && !reg_set_p (operands[1], operands[5])
+   && !reg_overlap_mentioned_p (operands[2], operands[5])"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (match_dup 2))
+	      (clobber (reg:CC CC_REGNUM))])
+   (match_dup 5)]
+  "")
+
+(define_peephole2
+  [(parallel [(set (match_operand:SI 0 "gpr_operand" "")
+		   (match_operand:SI 1 "pcrel_operand" ""))
+	      (clobber (match_operand:SI 2 "gpr_operand" ""))
+	      (clobber (reg:CC UNKNOWN_REGNUM))])]
+  "peep2_regno_dead_p (1, CC_REGNUM)"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (match_dup 2))
+	      (clobber (reg:CC CC_REGNUM))])]
+  "")
+
 (define_expand "mov<mode>"
   [(set (match_operand:DWMODE 0 "general_operand" "")
 	(match_operand:DWMODE 1 "general_operand" ""))]
@@ -2155,7 +2236,7 @@
     }
 })
 
-(define_insn "*tablejump_internal"
+(define_insn "tablejump_internal"
   [(set (pc) (match_operand:SI 0 "gpr_operand" "r"))
    (use (label_ref (match_operand 1 "" "")))]
   ""
@@ -2169,6 +2250,62 @@
   "jr %0;"
   [(set_attr "type" "uncond_branch")])
 
+; tablejump expansion will use CASE_VECTOR_MODE for the index scaling,
+; but we want CASE_VECTOR_SHORTEN_MODE to take effect.
+(define_expand "casesi"
+  [(match_operand:SI 0 "register_operand" "")   ; index to jump on
+   (match_operand:SI 1 "const_int_operand" "")  ; lower bound
+   (match_operand:SI 2 "const_int_operand" "")  ; total range
+   (match_operand 3 "" "")                      ; table label
+   (match_operand 4 "" "")]                     ; out of range label
+  "flag_pic"
+{
+  if (operands[1] != const0_rtx)
+    {
+      rtx reg = gen_reg_rtx (Pmode);
+      rtx offset = gen_int_mode (-INTVAL (operands[1]), Pmode);
+      
+      if (!add_operand (offset, Pmode))
+	offset = force_reg (Pmode, offset);
+
+      emit_insn (gen_addsi3 (reg, operands[0], offset));
+      operands[0] = reg;
+    }
+  emit_cmp_and_jump_insns (operands[0], operands[2], GTU, NULL_RTX, Pmode, 1,
+			   operands[4], -1);
+  rtx target = gen_reg_rtx (Pmode);
+  emit_insn (gen_casesi_load (target, operands[0], operands[3]));
+  emit_jump_insn (gen_tablejump_internal (target, operands[3]));
+  DONE;
+})
+
+(define_insn "casesi_load"
+  [(set (match_operand:SI 0 "gpr_operand" "=&r,r")
+	(unspec:SI [(match_operand:SI 1 "gpr_operand" "r,r")
+		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
+   (clobber (match_scratch:SI 3 "=X,r"))
+   (clobber (match_scratch:SI 4 "=r,r"))
+   (clobber (reg:CC CC_REGNUM))]
+  "flag_pic"
+{
+  rtx diff_vec = PATTERN (next_real_insn (operands[2]));
+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);
+  enum machine_mode mode = GET_MODE (diff_vec);
+  int shift = exact_log2 (GET_MODE_SIZE (mode));
+  if (!gpr_operand (operands[3], SImode))
+    operands[3] = operands[0];
+  asm_fprintf (asm_out_file, "0:");
+  output_asm_insn ("movfs %3,pc\;add %3,%3,(%2)-0b", operands);
+  rtx xop[3] = { operands[4], operands[1], GEN_INT (shift) };
+  output_asm_insn ("lsl %0,%1,%2", xop);
+  output_asm_insn (mode == HImode ? "ldrh %4,[%3,%4]" : "ldr %4,[%3,%4]",
+		   operands);
+  output_asm_insn ("add %0,%3,%4", operands);
+  return "";
+}
+  [(set_attr "type" "load")
+   (set_attr "length" "20")])
+
 
 /* For the overlay ABI, calls need to build a readily parsable frame
    for the benefit of callees (or the intercepting runtime on its behalf,
diff --git a/gcc/config/epiphany/predicates.md b/gcc/config/epiphany/predicates.md
index 406e767d19b..c8461b99936 100644
--- a/gcc/config/epiphany/predicates.md
+++ b/gcc/config/epiphany/predicates.md
@@ -132,6 +132,7 @@
     {
     case SYMBOL_REF :
     case LABEL_REF :
+      return !flag_pic || !pcrel_operand (op, Pmode);
     case CONST :
       return 1;
     case CONST_INT :
@@ -371,8 +372,15 @@
 (define_predicate "memclob_operand"
   (match_code "mem"))
 
-(define_predicate "nonsymbolic_immediate_operand"
-  (ior (match_test "immediate_operand (op, mode)")
+(define_predicate "pcrel_operand"
+  (ior (match_code "label_ref")
+       (and (match_code "const,plus")
+	    (match_test "pcrel_operand (XEXP (op, 0), mode)"))))
+; ??? should also include overlay-local SYMBOL_REFs, if we can identify these.
+
+(define_predicate "nonpcrel_immediate_operand"
+  (ior (and (match_operand 0 "immediate_operand")
+	    (not (match_operand 0 "pcrel_operand")))
        (match_code "const_vector"))) /* Is this specific enough?  */
 
 ;; Return true if OP is misaligned memory operand
-- 
2.31.1

