From b7ddbdcb6f0e58fb39eb203176a3cb6cc29a3e18 Mon Sep 17 00:00:00 2001
From: Joern Rennecke <joern.rennecke@embecosm.com>
Date: Thu, 1 Aug 2013 03:11:18 +0100
Subject: [PATCH 05/33] epiphany: Add TRACE_REGNUM

gcc/
	* config/epiphany/epiphany.h (FIRST_PSEUDO_REGISTER): Bump up to 79.
	(FIXED_REGISTERS, CALL_USED_REGISTERS): Include TRACE_REGNUM entry.
	(REG_ALLOC_ORDER, REGISTER_NAMES): Likewise.
	(REG_CLASS_CONTEENTS) <ALL_REGS>: Likewise.
	* config/epiphany/epiphany.md (TRACE_REGNUM): New constant.
	(call, call_i, sibcall, sibcall_i): Add use of trace.
	(call_value, call_value_i, sibcall_value, sibcall_value_i): Likewise.
	(stack_adjust_addfp): New pattern.
	(stack_adjust_mov): Use new hard frame pointer register.
	* config/epiphany/predicates.md (trace_operand): New predicate.
	(float_operation): Allow for three-element CALL_INSN patterns.
	* config/epiphany/epiphany.c (epiphany_expand_prologue):
	Don't use frame_insn for hard frame pointer initialization when
	frame_pointer_needed is not set.
	Add a REG_FRAME_RELATED_NOTE when adding a register to allocate a
	large frame.
	(epiphany_expand_epilogue): Fix sign of frame_adjust.
	Use gen_stack_adjust_addfp.
	(epiphany_initial_elimination_offset): Define elimination from
	TRACE_REGNUM.
	(epiphany_can_eliminate): Only restrict elimination from
	TRACE_REGNUM.

Reworded-by: Ola Jeppsson <ola.jeppsson@gmail.com>
---
 gcc/ChangeLog.epiphany            | 25 +++++++++++++++
 gcc/config/epiphany/epiphany.c    | 51 +++++++++++++++++++++++--------
 gcc/config/epiphany/epiphany.h    | 11 ++++---
 gcc/config/epiphany/epiphany.md   | 44 ++++++++++++++++++++------
 gcc/config/epiphany/predicates.md | 11 +++++--
 5 files changed, 115 insertions(+), 27 deletions(-)

diff --git a/gcc/ChangeLog.epiphany b/gcc/ChangeLog.epiphany
index 6209cfead2e..73ca6042d6c 100644
--- a/gcc/ChangeLog.epiphany
+++ b/gcc/ChangeLog.epiphany
@@ -1,3 +1,28 @@
+2013-08-01  Joern Rennecke <joern.rennecke@embecosm.com>
+
+	* config/epiphany/epiphany.h (FIRST_PSEUDO_REGISTER): Bump up to 79.
+	(FIXED_REGISTERS, CALL_USED_REGISTERS): Include TRACE_REGNUM entry.
+	(REG_ALLOC_ORDER, REGISTER_NAMES): Likewise.
+	(REG_CLASS_CONTEENTS) <ALL_REGS>: Likewise.
+	* config/epiphany/epiphany.md (TRACE_REGNUM): New constant.
+	(call, call_i, sibcall, sibcall_i): Add use of trace.
+	(call_value, call_value_i, sibcall_value, sibcall_value_i): Likewise.
+	(stack_adjust_addfp): New pattern.
+	(stack_adjust_mov): Use new hard frame pointer register.
+	* config/epiphany/predicates.md (trace_operand): New predicate.
+	(float_operation): Allow for three-element CALL_INSN patterns.
+	* config/epiphany/epiphany.c (epiphany_expand_prologue):
+	Don't use frame_insn for hard frame pointer initialization when
+	frame_pointer_needed is not set.
+	Add a REG_FRAME_RELATED_NOTE when adding a register to allocate a
+	large frame.
+	(epiphany_expand_epilogue): Fix sign of frame_adjust.
+	Use gen_stack_adjust_addfp.
+	(epiphany_initial_elimination_offset): Define elimination from
+	TRACE_REGNUM.
+	(epiphany_can_eliminate): Only restrict elimination from
+	TRACE_REGNUM.
+
 2013-07-31  Joern Rennecke <joern.rennecke@embecosm.com>
 
 	Overlay (-fpic) support:
diff --git a/gcc/config/epiphany/epiphany.c b/gcc/config/epiphany/epiphany.c
index bdefd75f471..c88f2365cfe 100644
--- a/gcc/config/epiphany/epiphany.c
+++ b/gcc/config/epiphany/epiphany.c
@@ -977,7 +977,13 @@ struct epiphany_frame_info
   bool frame_offset_known;
   int      stld_sz;             /* Current load/store data size for offset
 				   adjustment. */
-  int      need_fp;             /* value to override "frame_pointer_needed */
+  /* frame_pointer_needed indicates if the middle-end knows that a frame
+     pointer is needed.  NEED_FP will be set in that case, but also
+     when we need a frame pointer purely for overlay runtime backtrace
+     purposes.  In the latter case, we don't want the middle-end to
+     comletely stop frame pointer elimination, since stack offsets are
+     sometimes smaller.  */
+  int      need_fp;
   /* FIRST_SLOT is the slot that is saved first, at the very start of
      the frame, with a POST_MODIFY to allocate the frame, if the size fits,
      or at least the parm and register save areas, otherwise.
@@ -1908,14 +1914,18 @@ epiphany_expand_prologue (void)
 			      FIRST_PSEUDO_REGISTER, addr, 0);
   if (current_frame_info.need_fp)
     {
+      rtx insn;
       long frame_adjust
 	= ((current_frame_info.first_slot_offset - current_frame_info.reg_size)
 	   - current_frame_info.sft_hd_frame_offset);
       if (frame_adjust)
-	frame_insn (gen_addsi3_i (hard_frame_pointer_rtx, stack_pointer_rtx,
-				  GEN_INT (frame_adjust)));
+	insn = gen_addsi3_i (hard_frame_pointer_rtx, stack_pointer_rtx,
+			     GEN_INT (frame_adjust));
       else
-	frame_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);
+	insn
+	  = gen_rtx_SET (VOIDmode, hard_frame_pointer_rtx, stack_pointer_rtx);
+      (frame_pointer_needed ? frame_insn : emit_insn) (insn);
+	
     }
   /* For large frames, allocate bulk of frame.  This is usually joint with one
      register save.  */
@@ -1948,6 +1958,8 @@ epiphany_expand_prologue (void)
      use an add.  */
   else if (current_frame_info.last_slot_offset)
     {
+      rtx insn, note = NULL_RTX;
+
       mem = gen_frame_mem (BLKmode,
 			   plus_constant (Pmode, stack_pointer_rtx,
 					  current_frame_info.last_slot_offset));
@@ -1956,9 +1968,13 @@ epiphany_expand_prologue (void)
 	{
 	  reg = gen_rtx_REG (Pmode, GPR_IP);
 	  frame_move_insn (reg, off);
+	  note = gen_rtx_PLUS (Pmode, stack_pointer_rtx, off);
+	  note = gen_rtx_SET (VOIDmode, stack_pointer_rtx, note);
 	  off = reg;
 	}
-      frame_insn (gen_stack_adjust_add (off, mem));
+      insn = frame_insn (gen_stack_adjust_add (off, mem));
+      if (note)
+	add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);
     }
 }
 
@@ -1979,11 +1995,12 @@ epiphany_expand_epilogue (int sibcall_p)
       || (current_frame_info.last_slot_offset && current_frame_info.need_fp))
     {
       long frame_adjust
-	= ((current_frame_info.first_slot_offset - current_frame_info.reg_size)
-	   - current_frame_info.sft_hd_frame_offset);
+	= (current_frame_info.sft_hd_frame_offset
+	   - (current_frame_info.first_slot_offset
+	      - current_frame_info.reg_size));
       mem = gen_frame_mem (BLKmode, stack_pointer_rtx);
       if (frame_adjust)
-	emit_insn (gen_stack_adjust_add (GEN_INT (frame_adjust), mem));
+	emit_insn (gen_stack_adjust_addfp (GEN_INT (frame_adjust), mem));
       else
 	emit_insn (gen_stack_adjust_mov (mem));
     }
@@ -2065,6 +2082,9 @@ epiphany_initial_elimination_offset (int from, int to)
     return (current_frame_info.reg_size
 	    - ((current_frame_info.pretend_size + 4) & -8)
 	    + current_frame_info.sft_hd_frame_offset);
+  if (from == TRACE_REGNUM
+      && (to == HARD_FRAME_POINTER_REGNUM || to == STACK_POINTER_REGNUM))
+    return 0;
   gcc_unreachable ();
 }
 
@@ -3134,13 +3154,20 @@ epiphany_starting_frame_offset (void)
 /* Return true if register FROM can be eliminated via register TO.  */
 
 static bool
-epiphany_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)
+epiphany_can_eliminate (const int from, const int to)
 {
   /* When compiling for overlays, we require a frame pointer in all non-leaf
      functions so that the runtime can easily find all active functions.
-     In that case, also eliminate the argument pointer exclusively to the
-     hard frame pointer.  */
-  return !flag_pic || crtl->is_leaf || to != STACK_POINTER_REGNUM;
+     We still want to eliminate the frame pointer in memory accesses
+     wherever possible, to make use of shorter instruction encodings;
+     OTOH, the hard frame pointer must be always present, even if there
+     was no memory frame reference in this function.  For this reason,
+     we have (use TRACE_REGNUM) in every call insns, to show that the
+     call or callee might use the backtrace; in the pic case, this can be
+     eliminated to the hard frame pointer only.  */
+  return (from != TRACE_REGNUM
+	  || to == (flag_pic && !crtl->is_leaf
+		    ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM));
 }
 
 struct gcc_target targetm = TARGET_INITIALIZER;
diff --git a/gcc/config/epiphany/epiphany.h b/gcc/config/epiphany/epiphany.h
index 03354bba415..820d279c540 100644
--- a/gcc/config/epiphany/epiphany.h
+++ b/gcc/config/epiphany/epiphany.h
@@ -210,7 +210,7 @@ along with GCC; see the file COPYING3.  If not see
    All registers that the compiler knows about must be given numbers,
    even those that are not normally considered general registers.  */
 
-#define FIRST_PSEUDO_REGISTER 78
+#define FIRST_PSEUDO_REGISTER 79
 
 
 /* General purpose registers.  */
@@ -245,6 +245,7 @@ along with GCC; see the file COPYING3.  If not see
 	1, 1, 1, 1, 1, 1,               /* Core Control Registers.  */  \
 	1, 1, 1,			/* FP_{NEAREST,...}_REGNUM */\
 	1,				/* UNKNOWN_REGNUM - placeholder.  */\
+	1,				/* TRACE_REGNUM.  */\
 }
 
 /* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered (in
@@ -273,6 +274,7 @@ along with GCC; see the file COPYING3.  If not see
 	1, 1, 1, 1, 1, 1,               /* Core Control Registers.  */  \
 	1, 1, 1,			/* FP_{NEAREST,...}_REGNUM */\
 	1,				/* UNKNOWN_REGNUM - placeholder.  */\
+	1,				/* TRACE_REGNUM.  */\
 }
 
 #define REG_ALLOC_ORDER \
@@ -291,7 +293,7 @@ along with GCC; see the file COPYING3.  If not see
     14, 13, /* Link register, stack pointer.  */ \
     /* Can't allocate, but must name these... */ \
     28, 29, 30, 31, \
-    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77 \
+    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78 \
   }
 
 #define HARD_REGNO_RENAME_OK(SRC, DST) epiphany_regno_rename_ok (SRC, DST)
@@ -358,7 +360,7 @@ enum reg_class {
   { 0xffff100f,0xffffff00,0x0},  /* SIBCALL_REGS */			\
   { 0xffffffff,0xffffffff,0x0003}, /* GENERAL_REGS */			\
   { 0x00000000,0x00000000,0x03f0}, /* CORE_CONTROL_REGS */		\
-  { 0xffffffff,0xffffffff,0x3fff}, /* ALL_REGS */				\
+  { 0xffffffff,0xffffffff,0x7fff}, /* ALL_REGS */				\
 }
 
 
@@ -477,6 +479,7 @@ typedef struct GTY (()) machine_function
 #define ELIMINABLE_REGS						\
 {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},			\
  { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},		\
+ { TRACE_REGNUM, HARD_FRAME_POINTER_REGNUM},		\
  { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},                   \
  { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},		\
 }
@@ -722,7 +725,7 @@ typedef struct GTY (()) machine_function
   "r56", "r57", "r58", "r59", "r60", "r61", "r62", "r63",	\
   "ap",  "sfp", "cc1", "cc2",					\
   "config", "status", "lc", "ls", "le", "iret",			\
-  "fp_near", "fp_trunc", "fp_anyfp", "unknown"			\
+  "fp_near", "fp_trunc", "fp_anyfp", "unknown", "trace"		\
 }
 
 #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \
diff --git a/gcc/config/epiphany/epiphany.md b/gcc/config/epiphany/epiphany.md
index a52ca796e14..c90f65790a3 100644
--- a/gcc/config/epiphany/epiphany.md
+++ b/gcc/config/epiphany/epiphany.md
@@ -44,6 +44,7 @@
    (FP_TRUNCATE_REGNUM		75)
    (FP_ANYFP_REGNUM		76)
    (UNKNOWN_REGNUM		77) ; used for addsi3_r and friends
+   (TRACE_REGNUM		78) ; placeholder for GPR_FP use in calls
    ; We represent the return address as an unspec rather than a reg.
    ; If we used a reg, we could use register elimination, but eliminating
    ; to GPR_LR would make the latter visible to dataflow, thus making it
@@ -2175,7 +2176,8 @@
   ;; operands[2] is next_arg_register
   [(parallel [(call (match_operand:SI 0 "call_operand" "")
 		    (match_operand 1 "" ""))
-	     (clobber (reg:SI GPR_LR))])]
+	      (use (reg:SI TRACE_REGNUM))
+	      (clobber (reg:SI GPR_LR))])]
   ""
 {
   bool target_uninterruptible = epiphany_call_uninterruptible_p (operands[0]);
@@ -2191,7 +2193,9 @@
       emit_call_insn
 	(gen_rtx_PARALLEL
 	  (VOIDmode,
-	   gen_rtvec (2, gen_rtx_CALL (VOIDmode, operands[0], operands[1]),
+	   gen_rtvec (3, gen_rtx_CALL (VOIDmode, operands[0], operands[1]),
+			 gen_rtx_USE (VOIDmode,
+				      gen_rtx_REG (SImode, TRACE_REGNUM)),
 			 gen_rtx_CLOBBER (VOIDmode,
 					  gen_rtx_REG (SImode, GPR_LR)))));
       emit_insn (target_uninterruptible ? gen_gie (): gen_gid ());
@@ -2203,6 +2207,7 @@
   [(match_parallel 2 "float_operation"
      [(call (mem:SI (match_operand:SI 0 "call_address_operand" "Csy,r"))
 	    (match_operand 1 "" ""))
+      (use (match_operand:SI 3 "trace_operand" ""))
       (clobber (reg:SI GPR_LR))])]
   ""
   "%f0"
@@ -2213,7 +2218,8 @@
   ;; operands[2] is next_arg_register
   [(parallel [(call (match_operand:SI 0 "call_operand" "")
 		    (match_operand 1 "" ""))
-	     (return)])]
+	      (use (reg:SI TRACE_REGNUM))
+	      (return)])]
   ""
 {
   bool target_uninterruptible = epiphany_call_uninterruptible_p (operands[0]);
@@ -2229,7 +2235,9 @@
       emit_call_insn
 	(gen_rtx_PARALLEL
 	  (VOIDmode,
-	   gen_rtvec (2, gen_rtx_CALL (VOIDmode, operands[0], operands[1]),
+	   gen_rtvec (3, gen_rtx_CALL (VOIDmode, operands[0], operands[1]),
+			 gen_rtx_USE (VOIDmode,
+				      gen_rtx_REG (SImode, TRACE_REGNUM)),
 			 ret_rtx)));
       emit_insn (target_uninterruptible ? gen_gie (): gen_gid ());
       DONE;
@@ -2239,6 +2247,7 @@
 (define_insn "*sibcall_i"
   [(call (mem:SI (match_operand:SI 0 "call_address_operand" "Csy,Rsc"))
 	 (match_operand 1 "" ""))
+   (use (match_operand:SI 2 "trace_operand" ""))
    (return)]
   ""
   "@
@@ -2252,7 +2261,8 @@
   [(parallel [(set (match_operand 0 "gpr_operand" "=r")
 		   (call (match_operand:SI 1 "call_operand" "")
 			 (match_operand 2 "" "")))
-	     (clobber (reg:SI GPR_LR))])]
+	      (use (reg:SI TRACE_REGNUM))
+	      (clobber (reg:SI GPR_LR))])]
   ""
 {
   bool target_uninterruptible = epiphany_call_uninterruptible_p (operands[1]);
@@ -2268,9 +2278,11 @@
       emit_call_insn
 	(gen_rtx_PARALLEL
 	  (VOIDmode,
-	   gen_rtvec (2, gen_rtx_SET
+	   gen_rtvec (3, gen_rtx_SET
 			   (operands[0],
 			    gen_rtx_CALL (VOIDmode, operands[1], operands[2])),
+			 gen_rtx_USE (VOIDmode,
+				      gen_rtx_REG (SImode, TRACE_REGNUM)),
 			 gen_rtx_CLOBBER (VOIDmode,
 					  gen_rtx_REG (SImode, GPR_LR)))));
       emit_insn (target_uninterruptible ? gen_gie (): gen_gid ());
@@ -2283,6 +2295,7 @@
      [(set (match_operand 0 "gpr_operand" "=r,r")
 	   (call (mem:SI (match_operand:SI 1 "call_address_operand" "Csy,r"))
 	         (match_operand 2 "" "")))
+      (use (match_operand:SI 4 "trace_operand" ""))
       (clobber (reg:SI GPR_LR))])]
   ""
   "%f1"
@@ -2295,7 +2308,8 @@
   [(parallel [(set (match_operand 0 "gpr_operand" "=r")
 		   (call (match_operand:SI 1 "call_operand" "")
 			 (match_operand 2 "" "")))
-	     (return)])]
+	      (use (reg:SI TRACE_REGNUM))
+	      (return)])]
   ""
 {
   bool target_uninterruptible = epiphany_call_uninterruptible_p (operands[1]);
@@ -2311,9 +2325,11 @@
       emit_call_insn
 	(gen_rtx_PARALLEL
 	  (VOIDmode,
-	   gen_rtvec (2, gen_rtx_SET
+	   gen_rtvec (3, gen_rtx_SET
 			   (operands[0],
 			    gen_rtx_CALL (VOIDmode, operands[1], operands[2])),
+			 gen_rtx_USE (VOIDmode,
+				      gen_rtx_REG (SImode, TRACE_REGNUM)),
 			 ret_rtx)));
       emit_insn (target_uninterruptible ? gen_gie (): gen_gid ());
       DONE;
@@ -2324,6 +2340,7 @@
   [(set (match_operand 0 "gpr_operand" "=r,r")
 	(call (mem:SI (match_operand:SI 1 "call_address_operand" "Csy,Rsc"))
 	      (match_operand 2 "" "")))
+   (use (match_operand:SI 3 "trace_operand" ""))
    (return)]
   ""
   "@
@@ -2384,11 +2401,20 @@
   "reload_completed"
   "add sp,sp,%0")
 
+(define_insn "stack_adjust_addfp"
+  [(set (reg:SI GPR_SP)
+	(plus:SI (reg:SI GPR_FP) (match_operand:SI 0 "arith_operand" "rL")))
+   (clobber (reg:CC CC_REGNUM))
+   (clobber (reg:SI STATUS_REGNUM))
+   (clobber (match_operand:BLK 1 "memory_operand" "=m"))]
+  "reload_completed"
+  "add sp,r15,%0")
+
 (define_insn "stack_adjust_mov"
   [(set (reg:SI GPR_SP) (reg:SI GPR_FP))
    (clobber (match_operand:BLK 0 "memory_operand" "=m"))]
   "reload_completed"
-  "mov sp,fp"
+  "mov sp,r15"
   [(set_attr "type" "move")])
 
 (define_insn "stack_adjust_str"
diff --git a/gcc/config/epiphany/predicates.md b/gcc/config/epiphany/predicates.md
index a7d7cbbc0b6..6c5a278ccb3 100644
--- a/gcc/config/epiphany/predicates.md
+++ b/gcc/config/epiphany/predicates.md
@@ -54,6 +54,10 @@
   return call_address_operand (op, mode);
 })
 
+(define_predicate "trace_operand"
+  (and (match_code "reg")
+       (match_test "REGNO (op) == TRACE_REGNUM || REGNO (op) == GPR_SP || REGNO (op) == GPR_FP")))
+
 ;; general purpose register.
 (define_predicate "gpr_operand"
   (match_code "reg,subreg")
@@ -294,9 +298,12 @@
 
   if (count == 2
       /* Vector ashift has an extra use for the constant factor required to
-	 implement the shift as multiply.  */
+	 implement the shift as multiply.
+	 Calls have an extra use of TRACE_REGNUM.  */
+      || (count == 3 && GET_CODE (XVECEXP (op, 0, 0)) == CALL)
       || (count == 3 && GET_CODE (XVECEXP (op, 0, 0)) == SET
-	  && GET_CODE (XEXP (XVECEXP (op, 0, 0), 1)) == ASHIFT))
+	  && (GET_CODE (XEXP (XVECEXP (op, 0, 0), 1)) == ASHIFT
+	      || GET_CODE (XEXP (XVECEXP (op, 0, 0), 1)) == CALL)))
     return !inserted;
 
   /* combine / recog will pass any old garbage here before checking the
-- 
2.31.1

